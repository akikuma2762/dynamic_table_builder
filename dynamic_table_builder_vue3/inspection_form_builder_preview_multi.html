<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>æ‹–æ”¾æª¢æŸ¥è¡¨ Â· v7 LocalStorage æ•´åˆ</title>
    <style>
      /* --- èˆ‡å‰ç‰ˆç›¸åŒçš„æ¨£å¼ --- */
      body {
        font-family: "Segoe UI", Roboto, "Noto Sans TC", sans-serif;
        margin: 1.5rem;
        /* è®“å³å´ palette ä¸æœƒè“‹åˆ°å…§å®¹ */
        margin-right: 340px;
      }
      body.palette-collapsed {
        /* palette æ”¶åˆå¾Œé‚„åŸå¯¬åº¦ */
        margin-right: 24px;
      }
      #controls button {
        margin-right: 0.5rem;
        padding: 4px 10px;
      }

      .draggable-item {
        background: #fffbe6;
        border: 1px solid #f0c36d;
        padding: 0.4rem;
        cursor: grab;
        width: 420px;
      }

      .reusable {
        background: #e1f5fe;
        border-color: #03a9f4;
        width: 220px;
      }

      table {
        border-collapse: collapse;
        width: 100%;
        margin-top: 1rem;
      }

      th,
      td {
        border: 1px solid #999;
        padding: 0.6rem;
        min-height: 44px;
        text-align: left;
        vertical-align: top;
      }

      th {
        background: #f5f5f5;
      }

      td.drop-hover {
        background: #c8e6c9;
      }
      #tableWrap,
      #outputArea
      {
        margin-top: 2rem;
        border: 2px dashed #aaa;
        padding: 1rem;
      }

      .saved-block {
        border: 1px solid #777;
        padding: 0.5rem;
        margin-top: 0.8rem;
      }

      .saved-title {
        font-weight: bold;
        margin-bottom: 0.4rem;
      }

      .buttons-inline > button {
        margin-right: 0.5rem;
      }

      textarea {
        width: 180px;
        height: 60px;
        font-family: inherit;
      }

      .draggable-item textarea {
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
        resize: vertical;
        overflow-wrap: break-word;
      }

      .signature {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        align-items: center;
      }

      .sigCanvas {
        border: 1px solid #666;
        background: #fff;
        width: 100%;
        height: 60px;
        touch-action: none;
      }

      .clearSig {
        font-size: 0.75rem;
      }

      #sigModal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }

      #sigModal .modal-box {
        background: #fff;
        padding: 1rem;
        border-radius: 6px;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      #sigModal canvas {
        border: 1px solid #333;
      }

      .draggable-item .del-btn {
        text-align: end;
        font-size: 0.8rem;
        color: #f44336;
        cursor: pointer;
        user-select: none;
      }

      #builderPreview {
        border: 1px dashed #ccc;
        padding: 0.5rem;
        min-height: 40px;
        background: #fafafa;
      }

      .row-selected {
        background: #e3f2fd !important;
        color: #000 !important;
      }

      table.preview {
        text-align: center;
      }

      /* ===== å›ºå®šå´æ¬„ Palette ===== */
      #palette-wrapper {
        position: fixed;
        right: 0;
        top: 0;
        height: 100vh;
        width: 320px;
        background: #fafafa;
        border-left: 1px solid #ccc;
        box-shadow: -2px 0 5px rgba(0, 0, 0, 0.05);
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        padding: 12px 8px 12px 12px;
        z-index: 998;
        transition: transform 0.25s ease;
      }
      #palette-wrapper.collapsed {
        transform: translateX(100%);
      }
      /* palette æ²å‹•å€åŸŸ */
      #palette {
        flex: 1 1 auto;
        overflow-y: auto;
        padding-right: 4px; /* è®“å·è»¸æœ‰ä¸€é»ç©ºéš™ */
      }

      /* æ”¶åˆ/å±•é–‹æŠŠæ‰‹ */
      #palette-toggle {
        position: absolute;
        left: -30px;
        top: 50%;
        transform: translateY(-50%);
        width: 28px;
        height: 64px;
        border: 1px solid #ccc;
        border-radius: 6px 0 0 6px;
        background: #fafafa;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: -2px 0 5px rgba(0, 0, 0, 0.05);
        user-select: none;
        font-size: 14px;
      }

      /* palette æ¨™é¡Œ (å¯æ‘ºç–Š) */
      h4.collapsible {
        display: flex;
        align-items: center;
        cursor: pointer;
        margin: 0 0 0.25rem;
        font-weight: bold;
        user-select: none;
      }
      h4.collapsible .caret {
        margin-left: 6px;
        font-size: 0.9rem;
      }

      /* palette å…§å®¹å€å¡Š */
      .palette-block {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        padding: 0.5rem;
        border: 1px dashed #999;
        margin-bottom: 0.75rem;
      }
      .palette-block.collapsed {
        display: none;
      }

      /* å€å¡Šé…è‰² */
      .palette-block.native {
        background: #fffbe6;
        border-color: #f0c36d;
      }
      .palette-block.custom {
        background: #e8fbe9;
        border-color: #4caf50;
      }

      /* -------- palette å…§å…ƒç´  -------- */
      .draggable-item {
        background: #fff;
        border: 1px solid #bbb;
        padding: 0.4rem;
        cursor: grab;
        width: 280px;
        box-sizing: border-box;
      }
      .reusable {
        background: #e1f5fe;
        border-color: #03a9f4;
        /* width: 180px; */
      }
    </style>

    <!-- Quill WYSIWYG -->
    <link
      href="https://cdn.jsdelivr.net/npm/quill@2.0.0/dist/quill.snow.css"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/quill@2.0.0/dist/quill.min.js"></script>
  </head>

  <body>
    <h3>æ‹–æ”¾æª¢æŸ¥è¡¨ï¼ˆv7 LocalStorage æ•´åˆï¼‰</h3>

    <!-- -------- æ“ä½œæŒ‰éˆ• -------- -->
    <div id="controls">
      <button id="previewBtn">åŒ¯å‡º / é è¦½</button>
      <button id="reloadBtn">é‡æ–°è®€å–å„²å­˜è³‡æ–™</button>
      <button id="clearLSBtn">âš ï¸ æ¸…é™¤æ‰€æœ‰å„²å­˜</button>
    </div>

    <!-- -------- è‡ªè¨‚ Item ç”¢ç”Ÿå™¨ -------- -->
    <fieldset id="itemBuilder" style="margin-bottom: 1rem">
      <legend>è‡ªè¨‚æª¢æŸ¥é …ç›®ç”¢ç”Ÿå™¨</legend>

      <label>
        <div>Checkbox æ¨™ç±¤:</div>
        <input
          id="builderChkLabel"
          type="text"
          placeholder="OK"
          style="width: 120px"
        />
        <button id="btnAddChk" type="button">â• åŠ å…¥ Checkbox</button> </label
      ><br /><br />
      <label>
        <div>æ–‡å­—è¼¸å…¥ placeholder:</div>
        <input
          id="builderInputPH"
          type="text"
          placeholder="è«‹è¼¸å…¥â€¦"
          style="width: 160px"
        />
        <button id="btnAddInput" type="button">â• åŠ å…¥è¼¸å…¥æ¡†</button> </label
      ><br /><br />
      <div
        id="quillToolbar"
        style="border: 1px solid #ccc; border-bottom: none; margin-bottom: 0"
      >
        <span class="ql-formats">
          <button class="ql-bold"></button>
          <button class="ql-italic"></button>
          <button class="ql-underline"></button>
        </span>
        <span class="ql-formats">
          <button class="ql-list" value="ordered"></button>
          <button class="ql-list" value="bullet"></button>
        </span>
        <span class="ql-formats">
          <button class="ql-link"></button>

          <span class="ql-formats">
            <select class="ql-size">
              <option value="small"></option>
              <option selected></option>
              <option value="large"></option>
              <option value="huge"></option>
            </select>
            <select class="ql-color"></select>
            <select class="ql-background"></select>
          </span>
        </span>
      </div>
      <div
        id="quillEditor"
        style="
          max-width: 100%;
          height: 160px;
          border: 1px solid #ccc;
          margin-bottom: 4px;
        "
      ></div>
      <div id="builderPreview">(é è¦½å€)</div>
      <br />
      <button id="builderAddBtn" type="button">æ–°å¢åˆ°èª¿è‰²ç›¤</button>
      <button id="builderClearBtn" type="button">æ¸…ç©ºè¼¸å…¥</button>
    </fieldset>

    <div id="palette-wrapper">
      <div id="palette-toggle">â¯</div>
      <div id="palette-controls" style="margin-bottom: 0.5rem">
        <button id="toggleAll" class="small">å…¨éƒ¨æ”¶åˆ</button>
      </div>
      <div id="palette">
        <!-- åŸç”Ÿ -->
        <h4 class="collapsible">åŸç”Ÿé …ç›® <span class="caret">â–¼</span></h4>
        <div id="palette-native" class="palette-block native">
          <div
            id="chkReusable"
            class="draggable-item reusable"
            draggable="true"
          >
            <label><input type="checkbox" /> OK</label>
          </div>
          <div
            id="txtReusable"
            class="draggable-item reusable"
            draggable="true"
          >
            <textarea placeholder="è«‹è¼¸å…¥..."></textarea>
          </div>
          <div
            id="sigReusable"
            class="draggable-item reusable"
            draggable="true"
          >
            <div class="signature">
              <canvas class="sigCanvas" width="200" height="60"></canvas>
              <button class="clearSig">æ¸…é™¤</button>
            </div>
          </div>
        </div>
        <!-- è‡ªè¨‚ -->
        <h4 class="collapsible">è‡ªè¨‚é …ç›® <span class="caret">â–¼</span></h4>
        <div id="palette-custom" class="palette-block custom"></div>
      </div>
    </div>
    <h4>ç·¨è¼¯å€ï¼š</h4>
    <div id="tableWrap"></div>
    <h4>é è¦½å€ï¼š</h4>
    <div id="outputArea">(å°šæœªåŒ¯å‡º)</div>
    <!-- -------- ç°½å Modal -------- -->
    <div id="sigModal">
      <div class="modal-box">
        <canvas id="modalCanvas" width="400" height="200"></canvas>
        <div>
          <button id="modalClear">æ¸…é™¤</button
          ><button id="modalSave">å„²å­˜</button
          ><button id="modalCancel">å–æ¶ˆ</button>
        </div>
      </div>
    </div>

    <script>
      /* ===== Palette æ”¶åˆ / å±•é–‹ ===== */
      document.addEventListener("DOMContentLoaded", () => {
        const wrapper = document.getElementById("palette-wrapper");
        const toggle = document.getElementById("palette-toggle");
        if (!wrapper || !toggle) return; // é é˜² id æ‰“éŒ¯æˆ–ç¯€é»ç¼ºå¤±

        let collapsed = false;
        const update = () => {
          wrapper.classList.toggle("collapsed", collapsed);
          document.body.classList.toggle("palette-collapsed", collapsed);
          toggle.textContent = collapsed ? "â®" : "â¯";
        };
        toggle.addEventListener("click", () => {
          collapsed = !collapsed;
          update();
        });
        update(); // åˆå§‹ç‹€æ…‹
      });

      /* -------- palette æ‘ºç–Š & å…¨åŸŸé–‹é—œ -------- */
      document.addEventListener("DOMContentLoaded", () => {
        // å€‹åˆ¥æ‘ºç–Š
        document.querySelectorAll("h4.collapsible").forEach((h) => {
          h.addEventListener("click", () => {
            const caret = h.querySelector(".caret");
            const block = h.nextElementSibling;
            const collapsed = block.classList.toggle("collapsed");
            caret.textContent = collapsed ? "â–¶" : "â–¼";
          });
        });

        // å…¨éƒ¨æ”¶åˆ/å±•é–‹
        const toggleBtn = document.getElementById("toggleAll");
        let allCollapsed = false;
        toggleBtn.addEventListener("click", () => {
          allCollapsed = !allCollapsed;
          document.querySelectorAll("#palette .palette-block").forEach((bl) => {
            bl.classList.toggle("collapsed", allCollapsed);
            const caret = bl.previousElementSibling.querySelector(".caret");
            if (caret) caret.textContent = allCollapsed ? "â–¶" : "â–¼";
          });
          toggleBtn.textContent = allCollapsed ? "å…¨éƒ¨å±•é–‹" : "å…¨éƒ¨æ”¶åˆ";
        });
      });

      /* ===== helpers ===== */
      const contrast = (h) => {
        const r = parseInt(h.substr(1, 2), 16),
          g = parseInt(h.substr(3, 2), 16),
          b = parseInt(h.substr(5, 2), 16);
        return (r * 299 + g * 587 + b * 114) / 1000 >= 128 ? "#000" : "#fff";
      };
      const uid = () => `id_${Math.random().toString(36).slice(2, 10)}`;

      /* ===== leaf ===== */
      function leafCols(hRows) {
        const R = hRows.length,
          g = [];
        for (let r = 0; r < R; r++) {
          g[r] ??= [];
          let c = 0;
          hRows[r].forEach((cell) => {
            while (g[r][c]) c++;
            const cs = +cell.colspan || 1,
              rs = +cell.rowspan || 1;
            for (let rr = 0; rr < rs; rr++)
              for (let cc = 0; cc < cs; cc++) {
                g[r + rr] ??= [];
                g[r + rr][c + cc] = cell;
              }
            c++;
          });
        }
        return g[R - 1] || [];
      }

      /* ===== modal & signature ===== */
      const sigModal = document.getElementById("sigModal");
      const modalCanvas = document.getElementById("modalCanvas");
      const mCtx = modalCanvas.getContext("2d");
      mCtx.lineWidth = 2;
      mCtx.lineCap = "round";
      let mcDown = false,
        mcPrev = null,
        smallCvs = null;
      const posMC = (e) => {
        const r = modalCanvas.getBoundingClientRect();
        return {
          x: (e.touches ? e.touches[0].clientX : e.clientX) - r.left,
          y: (e.touches ? e.touches[0].clientY : e.clientY) - r.top,
        };
      };
      modalCanvas.onmousedown = (e) => {
        mcDown = true;
        mcPrev = posMC(e);
      };
      modalCanvas.onmousemove = (e) => {
        if (!mcDown) return;
        const p = posMC(e);
        mCtx.beginPath();
        mCtx.moveTo(mcPrev.x, mcPrev.y);
        mCtx.lineTo(p.x, p.y);
        mCtx.stroke();
        mcPrev = p;
        e.preventDefault();
      };
      window.onmouseup = () => (mcDown = false);
      modalCanvas.ontouchstart = (e) => {
        mcDown = true;
        mcPrev = posMC(e);
      };
      modalCanvas.ontouchmove = (e) => {
        if (!mcDown) return;
        const p = posMC(e);
        mCtx.beginPath();
        mCtx.moveTo(mcPrev.x, mcPrev.y);
        mCtx.lineTo(p.x, p.y);
        mCtx.stroke();
        mcPrev = p;
        e.preventDefault();
      };
      modalCanvas.ontouchend = () => (mcDown = false);
      document.getElementById("modalClear").onclick = () =>
        mCtx.clearRect(0, 0, modalCanvas.width, modalCanvas.height);
      document.getElementById("modalCancel").onclick = () => {
        sigModal.style.display = "none";
        smallCvs = null;
      };

      document.getElementById("modalSave").onclick = () => {
        if (smallCvs)
          smallCvs
            .getContext("2d")
            .drawImage(modalCanvas, 0, 0, smallCvs.width, smallCvs.height);
        sigModal.style.display = "none";
        smallCvs = null;
      };
      function initSignature(holder) {
        const cvs = holder.querySelector(".sigCanvas");
        if (!cvs || cvs.dataset.bound) return;
        cvs.dataset.bound = 1;
        const ctx = cvs.getContext("2d");
        ctx.lineWidth = 2;
        ctx.lineCap = "round";
        let down = false,
          prev = null;
        const pos = (e) => {
          const r = cvs.getBoundingClientRect();
          return {
            x: (e.touches ? e.touches[0].clientX : e.clientX) - r.left,
            y: (e.touches ? e.touches[0].clientY : e.clientY) - r.top,
          };
        };
        const start = (e) => {
          down = true;
          prev = pos(e);
        };
        const move = (e) => {
          if (!down) return;
          const p = pos(e);
          ctx.beginPath();
          ctx.moveTo(prev.x, prev.y);
          ctx.lineTo(p.x, p.y);
          ctx.stroke();
          prev = p;
          e.preventDefault();
        };
        cvs.onmousedown = start;
        cvs.onmousemove = move;
        window.addEventListener("mouseup", () => (down = false));
        cvs.ontouchstart = start;
        cvs.ontouchmove = move;
        cvs.ontouchend = () => (down = false);
        holder
          .querySelector(".clearSig")
          ?.addEventListener("click", () =>
            ctx.clearRect(0, 0, cvs.width, cvs.height)
          );
        cvs.onclick = () => {
          if (cvs.draggable === false) {
            smallCvs = cvs;
            mCtx.clearRect(0, 0, modalCanvas.width, modalCanvas.height);
            mCtx.drawImage(cvs, 0, 0, modalCanvas.width, modalCanvas.height);
            sigModal.style.display = "flex";
          }
        };
      }

      /* ===== v7 â†’ DOM ===== */
      function buildTableFromV7(v7, readOnly = false) {
        const leaf = leafCols(v7.headerRows);
        console.log("leafCols:", leaf);
        const colgroup =
          "<colgroup>" +
          leaf.map((l) => `<col style="width:${l.width || ""}%">`).join("") +
          "</colgroup>";
        const hBg = "#d9eaff",
          hColor = contrast(hBg);
        const thead = v7.headerRows
          .map(
            (r) =>
              "<tr>" +
              r
                .map(
                  (c) =>
                    `<th${c.colspan > 1 ? ` colspan="${c.colspan}"` : ""}${
                      c.rowspan > 1 ? ` rowspan="${c.rowspan}"` : ""
                    }${c.en ? ` data-column="${c.en}"` : ""} 
                    style="text-align:${c.align||'left'};
            color:${c.color||'#000'};
            font-size:${c.size||16}px;">
        ${c.text || "&nbsp;"}${c.en ? `<br><small>${c.en}</small>` : ""}</th>`
                )
                .join("") +
              "</tr>"
          )
          .join("");

        const rows = v7.dataRowsCfg.length,
          cols = leaf.length,
          occ = Array(rows)
            .fill(0)
            .map(() => Array(cols).fill(false));
        const tb = [];
        for (let r = 0; r < rows; r++) {
          const bg = v7.dataRowsCfg[r].color || "#ffffff",
            txt = contrast(bg);
          let tr = `<tr style="background:${bg};color:${txt};">`;
          for (let c = 0; c < cols; c++) {
            if (occ[r][c]) continue;
            const cell = v7.dataRowsCfg[r].cells[c] || {};
            let cs = +cell.colspan || 1;
            let rs = +cell.rowspan || 1;
            if (c + cs > cols) cs = cols - c;
            if (r + rs > rows) rs = rows - r;
            for (let rr = 0; rr < rs; rr++)
              for (let cc = 0; cc < cs; cc++) occ[r + rr][c + cc] = true;
            const data = (cs === 1 && rs === 1 && leaf[c]?.en) ? ` data-column=\"${leaf[c].en}\"` : "";
            // å„ªå…ˆ cell.align/color/sizeï¼Œç„¡å‰‡ fallback leaf
            const align = cell.align || leaf[c]?.align || "left";
            const fColor = cell.color || leaf[c]?.color || "#000";
            const fSize  = cell.size  || leaf[c]?.size  || 16;
            const htmlText = (cell.text || "").replace(/\n/g, "<br>");
            tr += `<td${data}${cs > 1 ? ` colspan=\"${cs}\"` : ""}${rs > 1 ? ` rowspan=\"${rs}\"` : ""} style=\"text-align:${align};color:${fColor};font-size:${fSize}px;\">${htmlText || "&nbsp;"}</td>`;
          }
          tr += "</tr>";
          tb.push(tr);
        }
        const tbl = document.createElement("table");
        tbl.innerHTML = `<style>.preview th{background:${hBg};color:${hColor};}</style>${colgroup}<thead>${thead}</thead><tbody>${tb.join(
          ""
        )}</tbody>`;
        tbl.className = "preview";
        tbl.id = "mainTable";

        /* â˜… é‚„åŸ canvas å…§å®¹ï¼Œå†æ±ºå®šæ˜¯å¦é–å®š */
        tbl.querySelectorAll("canvas.sigCanvas").forEach((cv) => {
          const url = cv.getAttribute("data-url");
          if (url) {
            const img = new Image();
            img.onload = () => {
              cv.getContext("2d").drawImage(img, 0, 0, cv.width, cv.height);
            };
            img.src = url;
          }
        });

        if (readOnly) {
          tbl
            .querySelectorAll("input,textarea,canvas")
            .forEach((el) => (el.style.pointerEvents = "none"));
        } else {
          tbl.querySelectorAll(".signature").forEach(initSignature);
          enableDrag(tbl);
        }
        return tbl;
      }

      /* === DOM â†’ v7  (â˜…åŠ å…¥ç°½åæ“·å–) === */
      function domToV7(tbl, headerRows) {
        // å‚³å…¥è©²å¼µè¡¨çš„ headerRowsï¼Œæ”¯æ´å¤šè¡¨æ ¼çµæ§‹
        const cols = leafCols(headerRows).length;

         /* å°‡ rgb(...) è½‰ #rrggbbï¼›å‚³å…¥ #xxxxxx æˆ–ç©ºå­—ä¸²å‰‡åŸæ¨£å›å‚³ */
  const toHex = (rgbStr) => {
    if (!rgbStr || rgbStr.startsWith('#')) return rgbStr || '';
    const m = rgbStr.match(/^rgb[a]?\s*\((\d+),\s*(\d+),\s*(\d+)/i);
    if (!m) return '';
    const h = (n) => ('0' + parseInt(n, 10).toString(16)).slice(-2);
    return `#${h(m[1])}${h(m[2])}${h(m[3])}`;
  };

        const tdToHtml = (td) => {
          const clone = td.cloneNode(true);
          /* checkbox */
          clone.querySelectorAll("input[type=checkbox]").forEach((inp) => {
            inp.checked
              ? inp.setAttribute("checked", "")
              : inp.removeAttribute("checked");
            inp.disabled = false;
          });
          /* textarea */
          clone.querySelectorAll("textarea").forEach((t) => {
            t.textContent = t.value;
          });

          /* text-input å…§å®¹ */
          clone.querySelectorAll("input[type=text]").forEach((inp) => {
            inp.setAttribute("value", inp.value); // å°‡ç•¶å‰å€¼å¯«å› value å±¬æ€§
          });

          clone.querySelectorAll(".del-btn").forEach((btn) => btn.remove());

          /* Canvas è™•ç†ï¼šä¿ç•™ç°½å */
          const srcCanv = [...td.querySelectorAll("canvas.sigCanvas")];
          const dstCanv = [...clone.querySelectorAll("canvas.sigCanvas")];
          srcCanv.forEach((src, i) => {
            const url = src.toDataURL(); // æœ‰å…§å®¹çš„ bitmap
            if (dstCanv[i]) dstCanv[i].setAttribute("data-url", url);
          });

          return clone.innerHTML || "&nbsp;";
        };

        /* === èµ°è¨ª <tbody> === */
        const body = [...tbl.querySelectorAll("tbody tr")].map((tr) => {
          /* â‘  å–å¾—è¡Œæ¨£å¼ */
          const bg = toHex(
            tr.style.backgroundColor || getComputedStyle(tr).backgroundColor
          );
          const styleStr = tr.getAttribute("style") || "";

          /* â‘¡ èµ°è¨ª cell */
          const row = { color: bg, style: styleStr, cells: [] };
          let ci = 0;
          [...tr.children].forEach((td) => {
            const cs = td.colSpan || 1,
              rs = td.rowSpan || 1;
            // è®€å– align/color/size
            const style = window.getComputedStyle(td);
            const align = td.style.textAlign || style.textAlign || "left";
            const color = toHex(td.style.color || style.color || "#000");
            let size = td.style.fontSize || style.fontSize || "16px";
            size = parseInt(size) || 16;
            row.cells[ci] = {
              text: tdToHtml(td),
              colspan: cs,
              rowspan: rs,
              align,
              color,
              size
            };
            for (let i = 1; i < cs; i++)
              row.cells[ci + i] = { text: "", colspan: 1, rowspan: 1, align: "left", color: "#000", size: 16 };
            ci += cs;
          });

          /* è£œæ»¿ä¸è¶³æ¬„ */
          while (row.cells.length < cols)
            row.cells.push({ text: "", colspan: 1, rowspan: 1, align: "left", color: "#000", size: 16 });
          return row;
        });

        // å›å‚³è©²å¼µè¡¨æ ¼çš„ v7 çµæ§‹
        return { headerRows, dataRowsCfg: body };
      }

      /* ===== æ‹–æ”¾ ===== */
      function enableDrag(tbl) {
        tbl.addEventListener("dragover", (e) => {
          if (e.target.tagName === "TD") {
            e.preventDefault();
            e.target.classList.add("drop-hover");
          }
        });
        tbl.addEventListener("dragleave", (e) => {
          if (e.target.tagName === "TD")
            e.target.classList.remove("drop-hover");
        });
        tbl.addEventListener("drop", (e) => {
          if (e.target.tagName !== "TD") return;
          e.preventDefault();
          e.target.classList.remove("drop-hover");
          const id = e.dataTransfer.getData("text/plain");
          const src = document.getElementById(id);
          if (!src) return;
          if (e.target.firstChild && !confirm("è¦†è“‹æ­¤æ ¼ï¼Ÿ")) return;
          const el = src.classList.contains("reusable")
            ? src.cloneNode(true)
            : src;
          el.id = "";
          el.draggable = false;
          el.style.cursor = "default";
          /* â˜… è‹¥æ ¼å­å…§å«åˆªé™¤éˆ•ï¼Œé»ä¸€ä¸‹å°±æŠŠæ•´æ ¼å…§å®¹æ¸…æ‰ */
          const del = el.querySelector(".del-btn");
          if (del) {
            del.onclick = (ev) => {
              ev.stopPropagation();
              const td = del.closest("td");
              if (td) td.innerHTML = "&nbsp;"; // è®Šå›ç©ºç™½æ ¼
            };
          }

          e.target.innerHTML = "";
          e.target.appendChild(el);
          initSignature(el);
        });
      }

      document.getElementById("palette").addEventListener("dragstart", (e) => {
        const it = e.target.closest(".draggable-item");
        if (it) e.dataTransfer.setData("text/plain", it.id);
      });

      /* ===== é€šç”¨åˆªé™¤æŒ‰éˆ•åŠŸèƒ½ ===== */
      function addDelBtn(div, onRemoved = null) {
        let del = div.querySelector(".del-btn");
        if (!del) {
          del = document.createElement("div");
          del.className = "del-btn";
          del.textContent = "âœ–";
          div.prepend(del);
        }
        del.onclick = (e) => {
          e.stopPropagation();
          if (!confirm("ç¢ºå®šè¦åˆªé™¤æ­¤é …ç›®ï¼Ÿ")) return;

          div.remove();
          if (typeof onRemoved === "function") onRemoved();
        };
      }

      /* ===== Builder (èˆ‡å‰ç‰ˆç›¸åŒ) ===== */
      const builderPreview = document.getElementById("builderPreview");

      document.getElementById("builderAddBtn").onclick = () => {
        if (builderPreview.textContent === "(é è¦½å€)") {
          alert("å°šæœªè¨­å®šå…§å®¹");
          return;
        }
        const div = document.createElement("div");
        div.className = "draggable-item reusable";
        div.id = "custom_" + uid();
        div.draggable = true;
        div.innerHTML = builderPreview.innerHTML;
        const del = document.createElement("div");
        // æ›ä¸Šåˆªé™¤éˆ•ï¼Œç§»é™¤å¾Œé †ä¾¿æ›´æ–°å­˜æª”
        addDelBtn(div, saveCustomPalette);
        document.getElementById("palette-custom").appendChild(div);
        saveCustomPalette();
      };
      document.getElementById("builderClearBtn").onclick = () => {
        document.getElementById("builderChkLabel").value = "";
        document.getElementById("builderInputPH").value = "";
      };

      /* ===== å„²å­˜ util ===== */
      const saveJSON = (key, obj) =>
        localStorage.setItem(key, JSON.stringify(obj));
      const readJSON = (key) => {
        const r = localStorage.getItem(key);
        return r ? JSON.parse(r) : null;
      };

      /* ===== é è¦½ / å„²å­˜ ===== */
      // å„²å­˜å¤šè¡¨æ ¼è³‡æ–™ï¼Œçµ±ä¸€ç¶“ç”± loadSelect ä¸‹æ‹‰é¸å–®èˆ‡ LIST_KEY ç®¡ç†
      function saveToLocalMultiCustom() {
        const sel = document.getElementById("loadSelect");
        let name = sel && sel.value ? sel.value : "";
        let save_name = prompt("è«‹è¼¸å…¥è¦å„²å­˜çš„æª”æ¡ˆåç¨±ï¼š");
        if (!save_name) { alert("æœªè¼¸å…¥åç¨±ï¼Œæœªå„²å­˜ã€‚"); return; }
        // å–å¾—æ‰€æœ‰è¡¨æ ¼çš„ v7 çµæ§‹
        const wrap = document.getElementById("outputArea");
        const tables = [...wrap.querySelectorAll("table")];
        if (tables.length === 0) { alert("æ²’æœ‰è¡¨æ ¼å¯å„²å­˜"); return; }
        // è®€å–åŸæœ‰è³‡æ–™ï¼ˆå¿…é ˆè®€å– dynamicTableMulti__ ä½œç‚º headerRows ä¾†æºï¼‰
        let obj = {};
        const raw = localStorage.getItem("dynamicTableMulti__" + name);
        if (raw) {
          try { obj = JSON.parse(raw); } catch (e) { obj = {}; }
        }
        // === æ–°å¢ï¼šå¦‚åç¨±é‡è¤‡ï¼Œè©¢å•æ˜¯å¦è¦†è“‹ ===
        let names = getPreviewNameList();
        if (names.includes(save_name)) {
          if (!confirm("åç¨±ã€Œ" + save_name + "ã€å·²å­˜åœ¨ï¼Œæ˜¯å¦è¦†è“‹ï¼Ÿ")) {
            alert("å·²å–æ¶ˆå„²å­˜ã€‚");
            return;
          }
        }
        // å–å¾—ç¾æœ‰è¡¨æ ¼å…§å®¹
        const multi = { configs: tables.map((tbl, idx) => domToV7(tbl, obj.configs ? obj.configs[idx]?.headerRows : [])) };
        // è¦†è“‹å­˜å›ï¼ˆå­˜åˆ° dynamicTableMultiPreview__ï¼‰
        localStorage.setItem("dynamicTableMultiPreview__" + save_name, JSON.stringify(multi));
        // ç¶­è­·é è¦½åç¨±æ¸…å–®
        if (!names.includes(save_name)) {
          names.push(save_name);
          localStorage.setItem(PREVIEW_LIST_KEY, JSON.stringify(names));
        }
        alert("å·²å„²å­˜é è¦½ç‚ºã€Œ" + save_name + "ã€");
      }

      function preview() {
        const wrap = document.getElementById("tableWrap");
        if (!wrap.hasChildNodes()) {
          alert("æ²’æœ‰è¡¨æ ¼");
          return;
        }
        // 1. è¤‡è£½æ‰€æœ‰ç¾æœ‰è¡¨æ ¼
        const cloneWrap = document.createElement("div");
        cloneWrap.className = "multi-preview";

        wrap.querySelectorAll("table").forEach((tbl) => {
          const clone = tbl.cloneNode(true);
          // è¤‡è£½ç°½å canvas
          [...tbl.querySelectorAll("canvas.sigCanvas")].forEach((src, i) => {
            const dst = clone.querySelectorAll("canvas.sigCanvas")[i];
            if (src && dst) {
              dst.getContext("2d").drawImage(src, 0, 0, dst.width, dst.height);
            }
          });
          enableDrag(clone);
          clone.querySelectorAll("canvas.sigCanvas").forEach((c) => c.removeAttribute("data-bound"));
          clone.querySelectorAll(".signature").forEach(initSignature);
          cloneWrap.appendChild(clone);
        });
        const outputArea = document.getElementById("outputArea");
        outputArea.innerHTML = "";
        outputArea.appendChild(cloneWrap);

        const bar = document.createElement("div");
        bar.className = "buttons-inline";
        const btnSave = document.createElement("button");
        btnSave.textContent = "å„²å­˜";
        bar.append(btnSave);
        outputArea.appendChild(bar);

        // === åƒ…ä¿ç•™å„²å­˜åŠŸèƒ½ ===
        function saveToLocalMultiCustom() {
          const sel = document.getElementById("loadSelect");
          let name = sel && sel.value ? sel.value : prompt("è«‹è¼¸å…¥è¦å„²å­˜çš„æª”æ¡ˆåç¨±ï¼š");
          if (!name) return;
          // å–å¾—ç›®å‰ç•«é¢æ‰€æœ‰è¡¨æ ¼çš„ v7 çµæ§‹
          const tables = [...outputArea.querySelectorAll("table")];
          // è®€å–ç¾æœ‰è³‡æ–™ï¼ˆå¦‚æœ‰ï¼‰
          let obj = {};
          const raw = localStorage.getItem("dynamicTableMulti__" + name);
          if (raw) {
            try { obj = JSON.parse(raw); } catch (e) { obj = {}; }
          }
          // ä»¥ç›®å‰ç•«é¢ç‚ºä¸»è¦†è“‹
          configs = tables.map((tbl, idx) => domToV7(tbl, configs[idx]?.headerRows || []));
          // å„²å­˜
          const key = `dynamicTableMulti__${name}`;
          localStorage.setItem(key, JSON.stringify({ configs }));
          // æ›´æ–°åç¨±æ¸…å–®
          let names = getBuilderNameList();
          if (!names.includes(name)) {
            names.push(name);
            localStorage.setItem(LIST_KEY, JSON.stringify(names));
          }
          refreshNameOptions(name);
          alert(`å·²å„²å­˜ç‚ºã€Œ${name}ã€`);
        }
        btnSave.onclick = saveToLocalMultiCustom;
      }

     

      // é è¦½å€åƒ…ä¿ç•™ã€Œå„²å­˜ã€æŒ‰éˆ•ï¼Œä¸¦å‘¼å« saveToLocalMultiCustom
      function preview() {
        const wrap = document.getElementById("tableWrap");
        if (!wrap.hasChildNodes()) {
          alert("æ²’æœ‰è¡¨æ ¼");
          return;
        }
        // 1. è¤‡è£½æ‰€æœ‰ç¾æœ‰è¡¨æ ¼
        const cloneWrap = document.createElement("div");
        cloneWrap.className = "multi-preview";
        wrap.querySelectorAll("table").forEach((tbl) => {
          const clone = tbl.cloneNode(true);
          // è¤‡è£½ç°½å canvas
          [...tbl.querySelectorAll("canvas.sigCanvas")].forEach((src, i) => {
            const dst = clone.querySelectorAll("canvas.sigCanvas")[i];
            if (src && dst) {
              dst.getContext("2d").drawImage(src, 0, 0, dst.width, dst.height);
            }
          });
          enableDrag(clone);
          clone.querySelectorAll("canvas.sigCanvas").forEach((c) => c.removeAttribute("data-bound"));
          clone.querySelectorAll(".signature").forEach(initSignature);
          cloneWrap.appendChild(clone);
        });
        const outputArea = document.getElementById("outputArea");
        outputArea.innerHTML = "";
        outputArea.appendChild(cloneWrap);
        const bar = document.createElement("div");
        bar.className = "buttons-inline";
        const btnSave = document.createElement("button");
        btnSave.textContent = "å„²å­˜";
        bar.append(btnSave);
        outputArea.appendChild(bar);
        btnSave.onclick = saveToLocalMultiCustom;
      }

      // å…¶é¤˜æ‰€æœ‰ localStorage å­˜å–å¤šè¡¨æ ¼è³‡æ–™çš„åœ°æ–¹ï¼Œè«‹çµ±ä¸€ç¶“ç”± loadSelect ä¸‹æ‹‰é¸å–®èˆ‡ LIST_KEY ç®¡ç†
      function buildMultiTables(configs, readOnly = false) {
        const wrap = document.getElementById("tableWrap");
        wrap.innerHTML = "";
        configs.forEach((v7, idx) => {
          const tbl = buildTableFromV7(v7, readOnly);
          const block = document.createElement("div");
          block.className = "table-block";
          block.innerHTML = `<div style="font-weight:bold;">è¡¨æ ¼ ${
            idx + 1
          }</div>`;
          block.appendChild(tbl);
          wrap.appendChild(block);
        });
      }

      /* ===== Working å€ ===== */
      function loadMultiWorking() {
        const sel = document.getElementById("loadSelect");
        if(!sel){
          document.getElementById("tableWrap").textContent = "(æ‰¾ä¸åˆ°é¸æ“‡å™¨)";
          return;
        }
        const name = sel.value;
        if(!name){
          document.getElementById("tableWrap").textContent = "(è«‹å…ˆé¸æ“‡æª”æ¡ˆ)";
          return;
        }
        const raw = localStorage.getItem("dynamicTableMulti__"+name);
        if (!raw) {
          document.getElementById("tableWrap").textContent = "(å°šç„¡è³‡æ–™)";
          return;
        }
        let obj;
        try {
          obj = JSON.parse(raw);
        } catch(e) {
          document.getElementById("tableWrap").textContent = "(è³‡æ–™æ ¼å¼éŒ¯èª¤)";
          return;
        }
        if (!obj.configs || !Array.isArray(obj.configs)) {
          document.getElementById("tableWrap").textContent = "(è³‡æ–™æ ¼å¼éŒ¯èª¤)";
          return;
        }
        buildMultiTables(obj.configs);
      }

      // å¤šè¡¨æ ¼ç‰ˆï¼šæ¸²æŸ“æ‰€æœ‰ tableConfigs
      function buildMultiTables(configs, readOnly = false) {
        const wrap = document.getElementById("tableWrap");
        wrap.innerHTML = "";
        configs.forEach((v7, idx) => {
          const tbl = buildTableFromV7(v7, readOnly);
          const block = document.createElement("div");
          block.className = "table-block";
          block.innerHTML = `<div style="font-weight:bold;">è¡¨æ ¼ ${
            idx + 1
          }</div>`;
          block.appendChild(tbl);
          wrap.appendChild(block);
        });
      }

      

      /* ===== Buttons ===== */
      document.getElementById("previewBtn").onclick = () => {
        // æ¥è‘—åŸ·è¡ŒåŸæœ¬çš„é è¦½åŠŸèƒ½
        preview();
        // 1. å–å¾— #tableWrap ä¸­æ‰€æœ‰å…·æœ‰ draggable-item å’Œ reusable é¡åˆ¥çš„å…ƒç´ 
        const outputArea = document.getElementById("outputArea");
        if (outputArea) {
          outputArea
            .querySelectorAll(".draggable-item.reusable")
            .forEach((el) => {
              el.classList.remove("draggable-item", "reusable"); // åªç§»é™¤ classï¼Œä¸åˆªé™¤å…ƒç´ 
              const delBtn = el.querySelector(".del-btn");
              if (delBtn) { delBtn.remove(); } // ä¿®æ­£æ‹¬è™Ÿ
            });
        }
      };
      document.getElementById("reloadBtn").onclick = () => {
        loadMultiWorking();
        initNativeDelBtns();
        loadCustomPalette();
      };
      document.getElementById("clearLSBtn").onclick = () => {
        if (confirm("ç¢ºå®šæ¸…é™¤æ‰€æœ‰å„²å­˜ï¼Ÿ")) {
          // æ¸…é™¤æ‰€æœ‰ dynamicTableMulti__ é–‹é ­çš„è³‡æ–™
          Object.keys(localStorage).forEach(k => {
            if (k.startsWith("dynamicTableMulti__")) localStorage.removeItem(k);
          });
          localStorage.removeItem(LIST_KEY);
          location.reload();
        }
      };
      document.addEventListener("keydown", (e) => {
        if (e.ctrlKey && e.key === "s") {
          e.preventDefault();
          preview();
        }
      });

      /* --- åŠ åœ¨ buildTableFromV7(...) ç”¢ç”Ÿã€Œå®Œæˆç‰ˆã€ä¹‹å¾Œ --- */
      function attachRowSelect(tbl) {
        tbl.addEventListener("click", (e) => {
          const tr = e.target.closest("tr");
          if (!tr) return;
          tr.classList.toggle("row-selected"); // ç¬¬äºŒæ¬¡å†é»æœƒç§»é™¤åº•è‰²
          var result = getSelectedRowsData(tbl); // é å…ˆå‘¼å«ä¸€æ¬¡ï¼Œç¢ºä¿å‡½å¼å­˜åœ¨
          console.log("å·²ç¶å®šè¡Œé¸æ“‡åŠŸèƒ½ï¼Œé»é¸è¡Œå¯åˆ‡æ›é¸ä¸­ç‹€æ…‹ã€‚");
          console.log("é¸ä¸­è¡Œè³‡æ–™ï¼š", result); // åˆå§‹æ™‚æ²’æœ‰é¸ä¸­è¡Œï¼Œçµæœç‚ºç©ºé™£åˆ—
        });
      }

      function getSelectedRowsData(tbl) {
        const rows = [...tbl.querySelectorAll("tr.row-selected")];
        return rows.map((r) => {
          const obj = {};
          r.querySelectorAll("td[data-column]").forEach((td) => {
            obj[td.dataset.column] = td.innerText.trim();
          });
          return obj;
        });
      }

      /* ===== Palette Save / Load & Init ===== */
      const CUSTOM_LIST_KEY = "paletteCustom";
      function saveCustomPalette() {
        const items = [
          ...document.querySelectorAll("#palette-custom .draggable-item"),
        ].map((el) => el.outerHTML);
        localStorage.setItem(CUSTOM_LIST_KEY, JSON.stringify(items));
      }
      function loadCustomPalette() {
        const raw = localStorage.getItem(CUSTOM_LIST_KEY);
        if (!raw) return;
        JSON.parse(raw).forEach((html) => {
          const tmp = document.createElement("div");
          tmp.innerHTML = html.trim();
          const div = tmp.firstElementChild;
          if (!div) return;
          div.id = "custom_" + uid();
          div.draggable = true;

          /* ä¿è­‰ del-btn å­˜åœ¨ä¸¦é‡ç¶ */
          // æ›ä¸Šåˆªé™¤éˆ•ï¼Œç§»é™¤å¾ŒåŒæ­¥æ›´æ–°å­˜æª”
          addDelBtn(div, saveCustomPalette);

          document.getElementById("palette-custom").appendChild(div);
        });
      }
      function initNativeDelBtns() {
        document
          .querySelectorAll("#palette-native .draggable-item")
          .forEach((div) => {
            addDelBtn(div); // ç¢ºä¿æ¯å€‹åŸç”Ÿé …ç›®éƒ½æœ‰åˆªé™¤æŒ‰éˆ•
          });
      }

      /* ===== Init ===== */
      //loadMultiWorking();

      /* ===== AutoInit native+custom ===== */
      document.addEventListener("DOMContentLoaded", () => {
        initNativeDelBtns();
        loadCustomPalette();
      });
    </script>
    <script>
      /* ===== Quill Integration ===== */
      /* ===== è‡ªè¨‚ Blotï¼šInline Checkbox & TextInput ===== */
      const InlineEmbed = Quill.import("blots/embed");

      /* ----- Checkbox (Inline) ----- */
      class CheckboxBlot extends InlineEmbed {
        static create(value = { label: "OK" }) {
          const node = super.create();
          node.setAttribute("contenteditable", "false");
          const input = document.createElement("input");
          input.type = "checkbox";
          input.value = value.label || "OK";
          input.style.margin = "0 4px 0 0";
          const text = document.createTextNode(value.label || "OK");
          node.appendChild(input);
          node.appendChild(text);
          return node;
        }
        static value(node) {
          return { label: node.textContent.trim() };
        }
      }
      CheckboxBlot.blotName = "checkbox";
      CheckboxBlot.tagName = "span";
      Quill.register(CheckboxBlot);

      /* ----- TextInput (Inline) ----- */
      class TextInputBlot extends InlineEmbed {
        static create(value = { placeholder: "è«‹è¼¸å…¥â€¦", width: "100px" }) {
          const node = super.create();
          node.setAttribute("contenteditable", "false");
          const input = document.createElement("input");
          input.type = "text";
          input.placeholder = value.placeholder || "";
          input.style.width = value.width || "100px";
          node.appendChild(input);
          return node;
        }
        static value(node) {
          const inp = node.querySelector("input");
          return {
            placeholder: inp?.placeholder || "",
            width: inp?.style.width || "",
          };
        }
      }
      TextInputBlot.blotName = "textinput";
      TextInputBlot.tagName = "span";
      Quill.register(TextInputBlot);

      let quill;
      function initQuillEditor() {
        const container = document.getElementById("quillEditor");
        if (!container) return;
        quill = new Quill(container, {
          theme: "snow",
          placeholder: "è«‹è¼¸å…¥æ–‡å­—æˆ–ä½¿ç”¨å³å´æŒ‰éˆ•æ’å…¥å…ƒä»¶â€¦",
          modules: { toolbar: "#quillToolbar" },
        });
        quill.on("text-change", syncQuillToPreview);
        syncQuillToPreview();
      }

      function syncQuillToPreview() {
        const html = quill ? quill.root.innerHTML.trim() : "";

        const builderPreview = document.getElementById("builderPreview");
        if (builderPreview) builderPreview.innerHTML = html || "(é è¦½å€)";
      }

      document.addEventListener("DOMContentLoaded", () => {
        initQuillEditor();

        // æ’å…¥ Checkbox
        const btnAddChk = document.getElementById("btnAddChk");
        if (btnAddChk) {
          btnAddChk.onclick = () => {
            const labelSource = document.getElementById("builderChkLabel");
            const label = labelSource ? labelSource.value.trim() : "OK";
            const index = quill.getSelection()?.index ?? quill.getLength();
            quill.insertEmbed(index, "checkbox", { label });
            quill.insertText(index + 1, " ");
            syncQuillToPreview();
          };
        }

        // æ’å…¥ Input
        const btnAddInput = document.getElementById("btnAddInput");
        if (btnAddInput) {
          btnAddInput.onclick = () => {
            const phSource = document.getElementById("builderInputPH");
            const ph = phSource ? phSource.value.trim() : "è«‹è¼¸å…¥â€¦";
            const index = quill.getSelection()?.index ?? quill.getLength();
            quill.insertEmbed(index, "textinput", {
              placeholder: ph,
              width: "100px",
            });
            quill.insertText(index + 1, " ");
            syncQuillToPreview();
          };
        }

        // æ¸…ç©º
        const clearBtn = document.getElementById("builderClearBtn");
        if (clearBtn) {
          clearBtn.onclick = () => {
            quill.setContents([]);
            syncQuillToPreview();
          };
        }
      });
    </script>
    <script>
// ===== å¤šè¡¨æ ¼ä¸‹æ‹‰é¸å–®èˆ‡è®€å–åŠŸèƒ½ =====
const LIST_KEY = "dynamicTableMulti__names";
const PREVIEW_LIST_KEY = "dynamicTableMultiPreview__names";
function getBuilderNameList(){
  try{ return JSON.parse(localStorage.getItem(LIST_KEY)) || []; }
  catch(e){ return []; }
}
function getPreviewNameList(){
  try{ return JSON.parse(localStorage.getItem(PREVIEW_LIST_KEY)) || []; }
  catch(e){ return []; }
}
function refreshNameOptions(selId=""){
  let sel = document.getElementById("loadSelect");
  if(!sel){
    sel = document.createElement("select");
    sel.id = "loadSelect";
    sel.innerHTML = '<option value="">-- é¸æ“‡æª”æ¡ˆ --</option>';
    const controls = document.getElementById("controls");
    if(controls) controls.appendChild(sel);
  }
  sel.innerHTML = '<option value="">-- é¸æ“‡æª”æ¡ˆ --</option>';
  getBuilderNameList().forEach(n=>{
    const o=document.createElement("option");
    o.value=o.textContent=n;
    if(n===selId) o.selected=true;
    sel.appendChild(o);
  });
}
function loadFromLocal(){
  const sel = document.getElementById("loadSelect");
  if(!sel){ alert("æ‰¾ä¸åˆ°é¸æ“‡å™¨"); return; }
  const name = sel.value;
  if(!name){ alert("è«‹å…ˆé¸æ“‡æª”æ¡ˆ"); return; }
  const raw = localStorage.getItem("dynamicTableMulti__"+name);
  if(!raw){ alert("æ‰¾ä¸åˆ°è³‡æ–™ï¼"); refreshNameOptions(); return; }
  try{
    const obj = JSON.parse(raw);
    buildMultiTables(obj.configs);
    alert("å·²è¼‰å…¥ã€Œ"+name+"ã€");
  }catch(e){
    alert("è³‡æ–™æ ¼å¼éŒ¯èª¤ï¼");
  }
}
// ä¿®æ­£ loadMultiWorkingï¼šæ ¹æ“š loadSelect é¸å–çš„å€¼æ­é… LIST_KEY å–å¾—è³‡æ–™
function loadMultiWorking() {
  const sel = document.getElementById("loadSelect");
  if(!sel){
    document.getElementById("tableWrap").textContent = "(æ‰¾ä¸åˆ°é¸æ“‡å™¨)";
    return;
  }
  const name = sel.value;
  if(!name){
    document.getElementById("tableWrap").textContent = "(è«‹å…ˆé¸æ“‡æª”æ¡ˆ)";
    return;
  }
  const raw = localStorage.getItem("dynamicTableMulti__"+name);
  if (!raw) {
    document.getElementById("tableWrap").textContent = "(å°šç„¡è³‡æ–™)";
    return;
  }
  let obj;
  try {
    obj = JSON.parse(raw);
  } catch(e) {
    document.getElementById("tableWrap").textContent = "(è³‡æ–™æ ¼å¼éŒ¯èª¤)";
    return;
  }
  if (!obj.configs || !Array.isArray(obj.configs)) {
    document.getElementById("tableWrap").textContent = "(è³‡æ–™æ ¼å¼éŒ¯èª¤)";
    return;
  }
  buildMultiTables(obj.configs);
}
// åˆå§‹åŒ–ä¸‹æ‹‰é¸å–®èˆ‡è®€å–æŒ‰éˆ•
(function(){
  document.addEventListener("DOMContentLoaded", () => {
    refreshNameOptions();
    let loadBtn = document.getElementById("loadBtn");
    if(!loadBtn){
      loadBtn = document.createElement("button");
      loadBtn.id = "loadBtn";
      loadBtn.textContent = "ğŸ“‚ è®€å–";
      const controls = document.getElementById("controls");
      if(controls) controls.appendChild(loadBtn);
    }
    loadBtn.onclick = loadFromLocal;
  });
})();
    </script>
  </body>
</html>
