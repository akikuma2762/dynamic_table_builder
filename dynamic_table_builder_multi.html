<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>å‹•æ…‹æ¬„ä½è¡¨æ ¼ç”¢ç”Ÿå™¨Â v7Â â€‘Â å¤šè¡¨æ ¼ (Autoâ€‘ScrollÂ +Â Rowâ€‘SwapÂ Alert)</title>
    <style>
      html,
      body {
        overscroll-behavior: contain;
      } /* é˜²æ­¢æ‹–æ›³æ™‚å½ˆå‡ºé‚Šç•Œ */
      /* â€”â€” åŸºæœ¬æ’ç‰ˆ â€”â€” */
      body {
        font-family: Arial, "Noto Sans TC", sans-serif;
        margin: 24px;
        line-height: 1.5;
      }
      h1 {
        margin-bottom: 16px;
      }
      fieldset {
        border: 1px solid #ccc;
        padding: 12px;
        margin-bottom: 16px;
        border-radius: 6px;
        min-width: 0;
      }
      legend {
        padding: 0 6px;
        font-weight: 600;
      }
      label {
        display: inline-block;
        margin-right: 8px;
        margin-bottom: 4px;
      }
      input[type="number"],
      select {
        width: 60px;
      }
      textarea {
        max-width: 100%;
        min-height: 100px;
        width: 100%;
        resize: none;
      }
      button {
        padding: 4px 10px;
        margin: 4px 4px;
        cursor: pointer;
      }

      /* â€”â€” é è¦½è¡¨æ ¼ â€”â€” */
      table.preview {
        border-collapse: separate;
        border-spacing: 0;
        width: 100%;
      }
      table.preview th,
      table.preview td {
        border-top: 1px solid #000;
        border-left: 1px solid #000;
        padding: 4px 6px;
        word-wrap: break-word;
      }
      table.preview th:last-child,
      table.preview td:last-child {
        border-right: 1px solid #000;
      }
      table.preview tbody tr:last-child td {
        border-bottom: 1px solid #000;
      }
      table.preview thead tr:first-child th:first-child {
        border-top-left-radius: 8px;
      }
      table.preview thead tr:first-child th:last-child {
        border-top-right-radius: 8px;
      }
      table.preview tbody tr:last-child td:first-child {
        border-bottom-left-radius: 8px;
      }
      table.preview tbody tr:last-child td:last-child {
        border-bottom-right-radius: 8px;
      }

      /* â€”â€” ç·¨è¼¯é¢æ¿ â€”â€” */
      .row-config {
        margin: 8px 0;
        padding: 8px;
        border: 1px dashed #aaa;
        border-radius: 4px;
      }
      .cell-config {
        display: flex;
        flex-direction: column;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 6px;
        background: #f9f9f9;
      }
      .cell-config input[type="text"],
      .cell-config input[type="number"] {
        width: 110px;
      }
      .cells-wrapper {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
        gap: 12px;
        margin-top: 6px;
        align-items: start;
      }
      .title {
        font-size: 14px;
        font-weight: bold;
        color: #333;
        background: #e0eaff;
        padding: 4px 8px;
        border-left: 4px solid #3a78c3;
        border-radius: 4px 0 0 4px;
        margin-bottom: 4px;
        display: inline-block;
        user-select: none;
      }
      .remove-button {
        background: #dc3545;
        color: #fff;
        border: none;
        border-radius: 4px;
        padding: 6px 16px;
        cursor: pointer;
      }
      .row-main-title {
        cursor: pointer;
        background: #e0eaff;
        font-weight: bold;
        padding: 6px;
        margin: 6px 0;
        user-select: none;
      }
      .row-main-title.drag-over {
        background: #cfe7ff !important;
      }
      .cell-config .body {
        display: flex;
        flex-direction: column;
        gap: 6px;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: #f9f9f9;
        transition: max-height 0.3s ease;
      }
      .cell-config.collapsed .body {
        display: none;
      }
      .cell-config .collapse-btn {
        background: transparent;
        border: none;
        font-size: 16px;
        line-height: 1;
        cursor: pointer;
      }
      .preview.merged {
        margin-top: -1px;
      }

      /* â€”â€” tableâ€‘output æ²å‹• â€”â€” */
      #table-output-wrapper {
        max-height: 60vh;
        overflow: auto;
        border: 1px solid #ddd;
        padding: 4px;
        margin-top: 12px;
      }
      .dataRowsDetail {
        overflow: auto;
        max-height: 300px;
      }
    </style>
  </head>
  <body>
    <h1>å‹•æ…‹æ¬„ä½è¡¨æ ¼ç”¢ç”Ÿå™¨Â v7Â â€‘Â å¤šè¡¨æ ¼</h1>
    <fieldset>
      <legend>è¡¨æ ¼æ•¸é‡</legend>
      <label
        >è¡¨æ ¼æ•¸é‡ <input type="number" id="numTables" min="1" value="1"
      /></label>
    </fieldset>
    <fieldset id="mergeOption" style="display: none">
      <legend>è¡¨æ ¼åˆä½µè¨­å®š</legend>
      <label><input type="checkbox" id="mergeTables" /> åˆä½µè¡¨æ ¼</label>
    </fieldset>
    <div id="tablesConfig"></div>
    
    <fieldset>
      <button id="generateBtn">ç”¢ç”Ÿè¡¨æ ¼</button>
    <legend>å„²å­˜ / è®€å–</legend>
    <input id="saveName" type="text" placeholder="è«‹è¼¸å…¥åç¨±â€¦" />
    <button id="saveBtn">ğŸ’¾ å„²å­˜</button>
    <select id="loadSelect"><option value="">-- é¸æ“‡æª”æ¡ˆ --</option></select>
    <button id="loadBtn">ğŸ“‚ è®€å–</button>
  </fieldset>

    <div id="table-output-wrapper"><div id="table-output"></div></div>

    <script>
const LIST_KEY = "dynamicTableMulti__names";           // å„²å­˜æ‰€æœ‰åç¨±æ¸…å–® (JSON array)



// è®€å–æ¸…å–®
    function getNameList(){
      try{ return JSON.parse(localStorage.getItem(LIST_KEY)) || []; }
      catch(e){ return []; }
    }
    function setNameList(arr){ localStorage.setItem(LIST_KEY, JSON.stringify(arr)); }

    function refreshNameOptions(selId=""){
      const sel = document.getElementById("loadSelect");
      sel.innerHTML = '<option value="">-- é¸æ“‡æª”æ¡ˆ --</option>';
      getNameList().forEach(n=>{
        const o=document.createElement("option");
        o.value=o.textContent=n;
        if(n===selId) o.selected=true;
        sel.appendChild(o);
      });
    }

      /********** å·¥å…· **********/
      const qs = (s, sc = document) => sc.querySelector(s);
      const contrast = (hex) => {
        const r = parseInt(hex.substr(1, 2), 16),
          g = parseInt(hex.substr(3, 2), 16),
          b = parseInt(hex.substr(5, 2), 16);
        return (r * 299 + g * 587 + b * 114) / 1000 >= 128 ? "#000" : "#fff";
      };

      /********** å…¨åŸŸç‹€æ…‹ **********/
      let tableConfigs = [];
      let scrollEl = null; // ç›®å‰ autoâ€‘scroll çš„ç›®æ¨™
      let dragging = false; // æ˜¯å¦è™•æ–¼æ‹–æ›³ç‹€æ…‹

      /********** åƒæ•¸ **********/
      const SCROLL_EDGE = 80; // é‚Šç·£æ„Ÿæ‡‰è·é›¢
      const SCROLL_STEP = 50; // æ¯æ¬¡æ²å‹•é‡

      /********** æ²å‹•è¼”åŠ© **********/
      function getScrollParent(node) {
        while (node && node !== document.body) {
          const s = getComputedStyle(node);
          if (/auto|scroll/.test(s.overflowY)) return node;
          node = node.parentElement;
        }
        return document.scrollingElement || document.documentElement;
      }
      function clampScroll(el, newTop) {
        const max = el.scrollHeight - el.clientHeight;
        el.scrollTop = Math.max(0, Math.min(max, newTop));
      }
      function autoScroll(e) {
        if (!dragging || !scrollEl) return;
        const rect = scrollEl.getBoundingClientRect
          ? scrollEl.getBoundingClientRect()
          : { top: 0, bottom: window.innerHeight };
        if (e.clientY < rect.top + SCROLL_EDGE) {
          // ä¸Šæ–¹
          if (
            scrollEl === document.scrollingElement ||
            scrollEl === document.documentElement
          ) {
            clampScroll(scrollEl, scrollEl.scrollTop - SCROLL_STEP);
          } else {
            scrollEl.scrollBy(0, -SCROLL_STEP);
          }
        } else if (e.clientY > rect.bottom - SCROLL_EDGE) {
          // ä¸‹æ–¹
          if (
            scrollEl === document.scrollingElement ||
            scrollEl === document.documentElement
          ) {
            clampScroll(scrollEl, scrollEl.scrollTop + SCROLL_STEP);
          } else {
            scrollEl.scrollBy(0, SCROLL_STEP);
          }
        }
      }
      function wheelDuringDrag(ev) {
        if (dragging && scrollEl) {
          ev.preventDefault();
          if (
            scrollEl === document.scrollingElement ||
            scrollEl === document.documentElement
          ) {
            clampScroll(scrollEl, scrollEl.scrollTop + ev.deltaY);
          } else {
            scrollEl.scrollBy({ top: ev.deltaY });
          }
        }
      }

      /********** é™åˆ¶æ‹–æ›³è¶…å‡ºè¦–çª— **********/
      function restrictDragViewport(ev) {
        if (!dragging) return;
        const x = ev.clientX,
          y = ev.clientY;
        if (x < 0) {
          window.scrollBy(-SCROLL_STEP, 0);
        } else if (x > window.innerWidth) {
          window.scrollBy(SCROLL_STEP, 0);
        }
        autoScroll(ev);
      } // æ°´å¹³æ–¹å‘äº¦åŠ å…¥å˜—è©¦æ²å‹•

      /********** INIT **********/
      window.addEventListener("load", () => {
        qs("#numTables").addEventListener("input", buildTableConfigs);
        qs("#mergeTables").addEventListener("change", buildTableConfigs);
        qs("#generateBtn").addEventListener("click", generateTables);
        qs("#saveBtn").addEventListener("click", saveToLocal);
        qs("#loadBtn").addEventListener("click", loadFromLocal);
        refreshNameOptions();
        buildTableConfigs();
        document.addEventListener("dragover", autoScroll); // è§¸ç™¼è‡ªå‹•æ²å‹•
        document.addEventListener("wheel", wheelDuringDrag, { passive: false }); // æ‹–æ›³æ™‚æ»¾è¼ªä¹Ÿèƒ½æ²
        document.addEventListener("drag", restrictDragViewport); // é™åˆ¶è¶…é‚Šç•Œ
        document.addEventListener("dragstart", () => {
          dragging = true;
          scrollEl = getScrollParent(event.target);
        });
        document.addEventListener("dragend", () => {
          dragging = false;
          scrollEl = null;
        });
      });

      /********** Build ConfigÂ UI **********/
      function buildTableConfigs() {
        const cnt = +qs("#numTables").value || 1;
        while (tableConfigs.length < cnt)
          tableConfigs.push({ headerRows: [], dataRowsCfg: [] });
        tableConfigs.length = cnt;
        const wrap = qs("#tablesConfig");
        wrap.innerHTML = "";
        tableConfigs.forEach((cfg, idx) => {
          const block = document.createElement("div");
          block.className = "table-config";
          block.innerHTML = `<h2>è¡¨æ ¼ ${idx + 1} è¨­å®š</h2>
<fieldset><legend>è¡¨é ­è¨­å®š</legend><label>è¡¨é ­åˆ—æ•¸ <select class="numHeaderRows" data-idx="${idx}"><option value="1">1</option><option value="2">2</option><option value="3">3</option></select></label><div class="headerRows" id="headerRows-${idx}"></div></fieldset>
<fieldset><legend>è³‡æ–™åˆ—è¨­å®š</legend><label>è³‡æ–™åˆ—æ•¸ <input type="number" class="dataRows" data-idx="${idx}" min="1"></label></fieldset>
<fieldset><legend>è‰²å½©è¨­å®š</legend><label>è¡¨é ­èƒŒæ™¯è‰² <input type="color" class="headerBg" data-idx="${idx}" value="#d9eaff"></label><label>é è¨­è³‡æ–™åˆ—èƒŒæ™¯è‰² <input type="color" class="dataBg" data-idx="${idx}" value="#ffffff"></label></fieldset>
<fieldset><legend>è³‡æ–™åˆ—è©³ç´°è¨­å®šï¼ˆå¯æ‹–æ›³äº¤æ›ï¼‰</legend><small>â€» éœ€å…ˆå»ºç«‹è¡¨é ­å¾Œæ‰èƒ½è¨­å®šã€‚</small><div class="dataRowsDetail" id="dataRowsDetail-${idx}"></div></fieldset>`;
          wrap.appendChild(block);
          // åˆå§‹å€¼
          qs(`.numHeaderRows[data-idx="${idx}"]`).value =
            cfg.headerRows.length || 1;
          qs(`.dataRows[data-idx="${idx}"]`).value =
            cfg.dataRowsCfg.length || 1;
          // ç›£è½
          qs(`.numHeaderRows[data-idx="${idx}"]`).addEventListener(
            "change",
            () => buildHeaderRows(idx)
          );
          qs(`.dataRows[data-idx="${idx}"]`).addEventListener("input", () =>
            buildDataRowsUI(idx)
          );
          buildHeaderRows(idx);
        });
        qs("#mergeOption").style.display = cnt > 1 ? "block" : "none";
      }

      /********** Header **********/
      function buildHeaderRows(t) {
        const cfg = tableConfigs[t];
        const rowsN = +qs(`.numHeaderRows[data-idx="${t}"]`).value;
        while (cfg.headerRows.length < rowsN) cfg.headerRows.push([]);
        cfg.headerRows.length = rowsN;
        const wrap = qs(`#headerRows-${t}`);
        wrap.innerHTML = "";
        cfg.headerRows.forEach((_, r) => {
          const row = document.createElement("div");
          row.className = "row-config";
          row.innerHTML = `<strong>ç¬¬ ${
            r + 1
          } åˆ—</strong> <button type="button" onclick="addHeaderCell(${t},${r})">æ–°å¢å„²å­˜æ ¼</button><div id="h-${t}-${r}" class="cells-wrapper"></div>`;
          wrap.appendChild(row);
          renderHeaderCells(t, r);
        });
        buildDataRowsUI(t);
      }
      function addHeaderCell(t, r) {
        tableConfigs[t].headerRows[r].push({
          text: "",
          en: "",
          colspan: 1,
          rowspan: 1,
          width: "",
          align: "left",
          color: "#000000",
          size: 16,
          indexed: false,
        });
        renderHeaderCells(t, r);
        buildDataRowsUI(t);
      }
      function removeHeaderCell(t, r, i) {
        tableConfigs[t].headerRows[r].splice(i, 1);
        renderHeaderCells(t, r);
        buildDataRowsUI(t);
      }
      function updateHeaderCell(t, r, i, k, v) {
        tableConfigs[t].headerRows[r][i][k] = v;
        buildDataRowsUI(t);
      }
      function renderHeaderCells(t, r) {
        const cells = tableConfigs[t].headerRows[r];
        const wrap = qs(`#h-${t}-${r}`);
        wrap.innerHTML = "";
        cells.forEach((cell, i) => {
          const d = document.createElement("div");
          d.className = "cell-config";
          d.innerHTML = `<div class="cell-header"><span>å„²å­˜æ ¼è¨­å®š-${
            i + 1
          }</span><button type="button" class="collapse-btn">â€“</button></div><div class="body"><label><div class="title">ä¸­æ–‡</div><input type="text" value="${
            cell.text
          }" oninput="updateHeaderCell(${t},${r},${i},'text',this.value)"></label><label><div class="title">è‹±æ–‡</div><input type="text" value="${
            cell.en
          }" oninput="updateHeaderCell(${t},${r},${i},'en',this.value)"></label><label><div class="title">åˆä½µæ¬„</div><input type="number" min="1" value="${
            cell.colspan
          }" oninput="updateHeaderCell(${t},${r},${i},'colspan',+this.value)"></label><label><div class="title">åˆä½µåˆ—</div><input type="number" min="1" value="${
            cell.rowspan
          }" oninput="updateHeaderCell(${t},${r},${i},'rowspan',+this.value)"></label><label><div class="title">å¯¬åº¦æ¯”ä¾‹</div><input type="number" min="0" value="${
            cell.width
          }" oninput="updateHeaderCell(${t},${r},${i},'width\',this.value)\"></label><label><div class="title">æ–‡å­—å°é½Š</div><select onchange="updateHeaderCell(${t},${r},${i},\'align\',this.value)"><option value="left">é å·¦</option><option value="center">ç½®ä¸­</option><option value="right">é å³</option></select></label><label><div class="title">å­—é«”é¡è‰²</div><input type="color" value="${
            cell.color
          }" onchange="updateHeaderCell(${t},${r},${i},\'color\',this.value)"></label><label><div class="title">å­—é«”å¤§å°(px)</div><input type="number" min="8" value="${
            cell.size
          }" oninput="updateHeaderCell(${t},${r},${i},\'size\',+this.value)"></label><label><div class="title">ç´¢å¼•</div><select onchange="updateHeaderCell(${t},${r},${i},'indexed',this.value==='true')"><option value="false">ä¸å•Ÿç”¨</option><option value="true">å•Ÿç”¨</option></select></label><button type="button" class="remove-button" onclick="removeHeaderCell(${t},${r},${i})">ç§»é™¤</button></div>`;
          const hdr = d.querySelector(".cell-header");
          const btn = d.querySelector(".collapse-btn");
          hdr.addEventListener("click", () => {
            d.classList.toggle("collapsed");
            btn.textContent = d.classList.contains("collapsed") ? "+" : "â€“";
          });
          wrap.appendChild(d);
        });
      }

      /********** Leaf **********/
      function getLeaf(cfg) {
        const g = [];
        const R = cfg.headerRows.length;
        for (let r = 0; r < R; r++) {
          g[r] ??= [];
          let c = 0;
          cfg.headerRows[r].forEach((cell) => {
            while (g[r][c]) c++;
            const cs = +cell.colspan || 1,
              rs = +cell.rowspan || 1;
            for (let rr = 0; rr < rs; rr++) {
              g[r + rr] ??= [];
              for (let cc = 0; cc < cs; cc++) {
                g[r + rr][c + cc] = {
                  text: cell.text,
                  en: cell.en,
                  width: cell.width,
                  align: cell.align,
                  color: cell.color,
                  size: cell.size,
                  indexed: cell.indexed,
                };
              }
            }
            c++;
          });
        }
        return R ? g[R - 1] : [];
      }

      /********** Data Rows **********/
      function buildDataRowsUI(t) {
        const cfg = tableConfigs[t];
        const leaf = getLeaf(cfg);
        const cols = leaf.length;
        const panel = qs(`#dataRowsDetail-${t}`);
        if (!cols) {
          panel.innerHTML = "";
          return;
        }
        const total = +qs(`.dataRows[data-idx="${t}"]`).value || 1;
        while (cfg.dataRowsCfg.length < total)
          cfg.dataRowsCfg.push({
            color: "",
            cells: Array.from({ length: cols }, () => ({
              text: "",
              colspan: 1,
              rowspan: 1,
            })),
          });
        cfg.dataRowsCfg.length = total;
        cfg.dataRowsCfg.forEach((r) => {
          while (r.cells.length < cols)
            r.cells.push({ text: "", colspan: 1, rowspan: 1 });
          r.cells.length = cols;
        });
        panel.innerHTML = "";
        cfg.dataRowsCfg.forEach((row, i) => {
          /* â€”â€” Title â€”â€” */
          const title = document.createElement("div");
          title.className = "row-main-title";
          title.textContent = `â–¶ è³‡æ–™åˆ— ${i + 1}`;
          title.draggable = true;
          title.dataset.idx = i;
          title.addEventListener("dragstart", (e) => {
            scrollEl = getScrollParent(title);
            scrollEl.addEventListener("wheel", wheelDuringDrag, {
              passive: false,
            });
            e.dataTransfer.setData("text/plain", title.dataset.idx);
          });
          title.addEventListener("dragover", (e) => {
            e.preventDefault();
            autoScroll(e);
            title.classList.add("drag-over");
          });
          title.addEventListener("dragleave", () =>
            title.classList.remove("drag-over")
          );
          title.addEventListener("drop", (e) => {
            e.preventDefault();
            title.classList.remove("drag-over");
            const from = +e.dataTransfer.getData("text/plain");
            const to = +title.dataset.idx;
            if (from === to) return;
            const moved = cfg.dataRowsCfg.splice(from, 1)[0];
            cfg.dataRowsCfg.splice(to, 0, moved);
            buildDataRowsUI(t);
            alert(`å·²å°‡è³‡æ–™åˆ— ${from + 1} èˆ‡ ${to + 1} äº¤æ›é †åº`);
          });
          title.addEventListener("dragend", () => {
            if (scrollEl) {
              scrollEl.removeEventListener("wheel", wheelDuringDrag);
              scrollEl = null;
            }
          });
          title.addEventListener("click", () => {
            const body = qs(`#d-${t}-${i}`);
            if (body.style.display === "none") {
              body.style.display = "block";
              title.textContent = `â–¼ è³‡æ–™åˆ— ${i + 1}`;
            } else {
              body.style.display = "none";
              title.textContent = `â–¶ è³‡æ–™åˆ— ${i + 1}`;
            }
          });
          panel.appendChild(title);
          /* â€”â€” Body â€”â€” */
          const body = document.createElement("div");
          body.className = "row-config";
          body.id = `d-${t}-${i}`;
          body.style.display = "none";
          body.innerHTML = `<label>èƒŒæ™¯è‰² <input type="color" value="${
            row.color || "#ffffff"
          }" onchange="tableConfigs[${t}].dataRowsCfg[${i}].color=this.value"></label><div id="d-cells-${t}-${i}" class="cells-wrapper"></div>`;
          panel.appendChild(body);
          renderDataCells(t, i);
        });
        updateDataRowLabels(t);
      }
      function renderDataCells(t, r) {
        const cfg = tableConfigs[t];
        const leaf = getLeaf(cfg);
        const wrap = qs(`#d-cells-${t}-${r}`);
        wrap.innerHTML = "";
        cfg.dataRowsCfg[r].cells.forEach((cell, i) => {
          const cc = document.createElement("div");
          cc.className = "cell-config collapsed";
          const label = leaf[i]?.text || "æ¬„ä½åç¨±";
          // è‹¥ç‚ºç´¢å¼•æ¬„ï¼Œé¡¯ç¤ºæ’åºæ•¸å­—ä¸” disabled
          let cellContent = '';
         
            cellContent = `<label><div class="title">${label}</div><textarea oninput="tableConfigs[${t}].dataRowsCfg[${r}].cells[${i}].text=this.value;this.style.height='auto';this.style.height=this.scrollHeight+'px';">${cell.text||''}</textarea></label>`;
          
          cc.innerHTML = `<div class="cell-header"><span>${label}</span><button type="button" class="collapse-btn">+</button></div><div class="body">${cellContent}<label><div class="title">åˆä½µæ¬„</div><input type="number" min="1" value="${cell.colspan||1}" oninput="tableConfigs[${t}].dataRowsCfg[${r}].cells[${i}].colspan=+this.value"></label><label><div class="title">åˆä½µåˆ—</div><input type="number" min="1" value="${cell.rowspan||1}" oninput="tableConfigs[${t}].dataRowsCfg[${r}].cells[${i}].rowspan=+this.value"></label><label><div class="title">æ–‡å­—å°é½Š</div><select onchange="tableConfigs[${t}].dataRowsCfg[${r}].cells[${i}].align=this.value"><option value="left"${cell.align==="left"?" selected":""}>é å·¦</option><option value="center"${cell.align==="center"?" selected":""}>ç½®ä¸­</option><option value="right"${cell.align==="right"?" selected":""}>é å³</option></select></label><label><div class="title">å­—é«”é¡è‰²</div><input type="color" value="${cell.color||'#000000'}" onchange="tableConfigs[${t}].dataRowsCfg[${r}].cells[${i}].color=this.value"></label><label><div class="title">å­—é«”å¤§å°(px)</div><input type="number" min="8" value="${cell.size||16}" oninput="tableConfigs[${t}].dataRowsCfg[${r}].cells[${i}].size=+this.value"></label></div>`;
          const hdr = cc.querySelector(".cell-header");
          const btn = cc.querySelector(".collapse-btn");
          hdr.addEventListener("click", () => {
            cc.classList.toggle("collapsed");
            btn.textContent = cc.classList.contains("collapsed") ? "+" : "â€“";
          });
          wrap.appendChild(cc);
        });
      }
      function updateDataRowLabels(t) {
        const leaf = getLeaf(tableConfigs[t]);
        tableConfigs[t].dataRowsCfg.forEach((_, ri) => {
          leaf.forEach((col, ci) => {
            const e = qs(
              `#d-cells-${t}-${ri} .cell-config:nth-child(${ci + 1}) .title`
            );
            if (e && col.text) e.textContent = col.text;
          });
        });
      }

      /********** BuildÂ HTMLÂ Table for Preview **********/
      function buildTbody(cfg, defaultBg) {
        const leaf = getLeaf(cfg);
        const indexColumns = leaf
          .map((l, i) => (l.indexed ? i : null))
          .filter((i) => i !== null);
        let indexCounter = 1;
        const cols = leaf.length, rows = cfg.dataRowsCfg.length;
        const occ = Array.from({ length: rows }, () => Array(cols).fill(false));
        let out = "";
        for (let r = 0; r < rows; r++) {
          let rowIndexed = false;
          const bg = cfg.dataRowsCfg[r].color || defaultBg;
          const txt = contrast(bg);
          out += `<tr style="background:${bg};color:${txt};">`;
          for (let c = 0; c < cols; c++) {
            if (occ[r][c]) continue;
            const cell = cfg.dataRowsCfg[r].cells[c];
            let cs = +cell.colspan || 1,
              rs = +cell.rowspan || 1;
            if (c + cs > cols) cs = cols - c;
            if (r + rs > rows) rs = rows - r;
            for (let rr = 0; rr < rs; rr++) {
              for (let cc = 0; cc < cs; cc++) {
                occ[r + rr][c + cc] = true;
              }
            }
            const data =
              cs === 1 && rs === 1 && leaf[c].en
                ? ` data-column="${leaf[c].en}"`
                : "";

            let raw = cell.text ?? "";
            let html = raw.replace(/\n/g, "<br>");
            if (!html) html = "&nbsp;";
            // index column auto number
            if (indexColumns.includes(c) && cs === 1 && rs === 1) {
              html = indexCounter;
              rowIndexed = true;
            }
            // æ–°å¢ cell.style
            const align = cell.align || "left";
            const color = cell.color || "";
            const size = cell.size || 16;
            out += `<td${data}${cs > 1 ? ` colspan=\"${cs}\"` : ""}${
              rs > 1 ? ` rowspan=\"${rs}\"` : ""
            } style=\"text-align:${align};${color?`color:${color};`:""}${size?`font-size:${size}px;`:""}\">${html}</td>`;
          }
          if (rowIndexed) indexCounter++;
          out += `</tr>`;
        }
        return out;
      }
      function generateTables() {
        const merge = qs("#mergeTables").checked;
        const container = qs("#table-output");
        container.innerHTML = "";
        tableConfigs.forEach((cfg, idx) => {
          const hBg = qs(`.headerBg[data-idx="${idx}"]`).value;
          const dBg = qs(`.dataBg[data-idx="${idx}"]`).value;
          const hColor = contrast(hBg);
          const leaf = getLeaf(cfg);
          const colgroup = `<colgroup>${leaf
            .map(
              (l) =>
                `<col style="${l.width ? `width:${l.width}%;` : ""}"></col>`
            )
            .join("")}</colgroup>`;
          const thead = cfg.headerRows
            .map(
              (r) =>
                `<tr>${r
                  .map(
                    (cell) =>
                      `<th${
                        cell.colspan > 1 ? ` colspan="${cell.colspan}"` : ""
                      }${cell.rowspan > 1 ? ` rowspan="${cell.rowspan}"` : ""}${
                        cell.en ? ` data-column="${cell.en}"` : ""
                      } style="text-align:${cell.align};color:${
                        cell.color
                      };font-size:${cell.size}px;">${cell.text || "&nbsp;"}${
                        cell.en ? `<br><small>${cell.en}</small>` : ""
                      }</th>`
                  )
                  .join("")}</tr>`
            )
            .join("");
          const tbody = buildTbody(cfg, dBg);
          const tblHtml = `<style>.tbl-${idx} th{background:${hBg};color:${hColor};}</style><table class="preview tbl-${idx}${
            merge && idx > 0 ? " merged" : ""
          }">${colgroup}<thead>${thead}</thead><tbody>${tbody}</tbody></table>`;
          container.insertAdjacentHTML("beforeend", tblHtml);
        });
      }

      /********** LocalÂ Storage **********/
      /* === åŸ saveToLocal æ”¹å¯« === */
    function saveToLocal(){
      const name = document.getElementById("saveName").value.trim();
      if(!name){ alert("è«‹è¼¸å…¥æª”åï¼"); return; }
      const key = "dynamicTableMulti__" + name;
      if(localStorage.getItem(key) && !confirm("å·²å­˜åœ¨åŒåæª”æ¡ˆï¼Œæ˜¯å¦è¦†è“‹ï¼Ÿ")) return;

      // â€» æ­¤è™• tableConfigs / å…¶é¤˜ç‹€æ…‹èˆ‡èˆŠç‰ˆç›¸åŒ
      const payload = {
        configs: tableConfigs,
        numTables: +document.getElementById("numTables").value,
        merge: document.getElementById("mergeTables").checked
      };
      localStorage.setItem(key, JSON.stringify(payload));

      // æ›´æ–°åç¨±æ¸…å–®
      const list = getNameList();
      if(!list.includes(name)){ list.push(name); setNameList(list); }
      refreshNameOptions(name);
      alert("å·²å„²å­˜ç‚ºã€Œ" + name + "ã€");
    }
      /* === åŸ loadFromLocal æ”¹å¯« === */
    function loadFromLocal(){
      const name = document.getElementById("loadSelect").value;
      if(!name){ alert("è«‹å…ˆé¸æ“‡æª”æ¡ˆ"); return; }
      const raw = localStorage.getItem("dynamicTableMulti__"+name);
      if(!raw){ alert("æ‰¾ä¸åˆ°è³‡æ–™ï¼"); refreshNameOptions(); return; }
      try{
        const obj = JSON.parse(raw);
        document.getElementById("numTables").value = obj.numTables;
        document.getElementById("mergeTables").checked = obj.merge;
        tableConfigs = obj.configs;
        buildTableConfigs();
        generateTables();
      }catch(e){
        alert("è³‡æ–™æ ¼å¼éŒ¯èª¤ï¼");
      }
    }
    // ä¾ç…§è©³ç´°è³‡æ–™åˆ—å€å¡Šå…§å®¹çµ„æˆ tableConfigs ç‰©ä»¶
function getCurrentTableConfigsFromDetail() {
  const configs = [];
  const tables = document.querySelectorAll('.table-config');
  tables.forEach((tableBlock, tIdx) => {
    // å–å¾— headerRows
    const headerRows = [];
    tableBlock.querySelectorAll('.headerRows .row-config').forEach((rowDiv) => {
      const cells = [];
      rowDiv.querySelectorAll('.cell-config').forEach((cellDiv) => {
        const text = cellDiv.querySelector('input[type="text"]')?.value || '';
        const en = cellDiv.querySelectorAll('input[type="text"]')[1]?.value || '';
        const colspan = +(cellDiv.querySelector('input[type="number"][min="1"]')?.value || 1);
        const rowspan = +(cellDiv.querySelectorAll('input[type="number"][min="1"]')[1]?.value || 1);
        const width = cellDiv.querySelector('input[type="number"][min="0"]')?.value || '';
        const align = cellDiv.querySelector('select')?.value || 'left';
        const color = cellDiv.querySelector('input[type="color"]')?.value || '#000000';
        const size = +(cellDiv.querySelectorAll('input[type="number"]')[2]?.value || 16);
        const indexed = cellDiv.querySelectorAll('select')[1]?.value === 'true';
        cells.push({ text, en, colspan, rowspan, width, align, color, size, indexed });
      });
      headerRows.push(cells);
    });
    // å–å¾— dataRowsCfg
    const dataRowsCfg = [];
    tableBlock.querySelectorAll('.dataRowsDetail .row-config').forEach((rowDiv, rIdx) => {
      const color = rowDiv.querySelector('input[type="color"]')?.value || '';
      const cells = [];
      rowDiv.querySelectorAll('.cell-config').forEach((cellDiv, cIdx) => {
        // åˆ¤æ–·æ˜¯å¦ç‚ºç´¢å¼•æ¬„
        const isIndex = headerRows[0]?.[cIdx]?.indexed;
        let text = '';
        if (isIndex) {
          text = String(rIdx + 1);
        } else {
          text = cellDiv.querySelector('textarea')?.value || '';
        }
        const colspan = +(cellDiv.querySelector('input[type="number"][min="1"]')?.value || 1);
        const rowspan = +(cellDiv.querySelectorAll('input[type="number"][min="1"]')[1]?.value || 1);
        const align = cellDiv.querySelector('select')?.value || 'left';
        const colorCell = cellDiv.querySelector('input[type="color"]')?.value || '#000000';
        const size = +(cellDiv.querySelectorAll('input[type="number"]')[2]?.value || 16);
        cells.push({ text, colspan, rowspan, align, color: colorCell, size });
      });
      dataRowsCfg.push({ color, cells });
    });
    configs.push({ headerRows, dataRowsCfg });
  });
  return configs;
}
    </script>
  </body>
</html>
